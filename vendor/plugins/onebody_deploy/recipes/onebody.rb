# OneBody Deploy Tasks
#
# Much of this code was borrowed from Geoffrey Grosenbach's Capistrano screencast.
# http://peepcode.com
#
# Author: Geoffrey Grosenbach http://topfunky.com
#         November 2007
#
# Author: Tim Morgan http://timmorgan.org
#         March 2008

namespace :deploy do
  
  desc 'Starts one or more thin servers.'
  task :start, :roles => :app do
    as = fetch(:runner, 'app')
    via = fetch(:run_method, :sudo)
    count = fetch(:thin_servers, 1)
    port = fetch(:thin_port, 8000)
    env = fetch(:rails_env, 'production')
    cmd = "sh -c 'cd #{current_path} && thin start -d -e #{env} -p #{port} -s #{count} -P #{shared_path}/pids/thin.pid -l #{shared_path}/log/thin.log'"
    invoke_command cmd, :via => via, :as => as
  end
  
  desc 'Stops one or more running thin servers.'
  task :stop, :roles => :app do
    as = fetch(:runner, 'app')
    via = fetch(:run_method, :sudo)
    count = fetch(:thin_servers, 1)
    port = fetch(:thin_port, 8000)
    cmd = "sh -c 'cd #{current_path} && thin stop -p #{port} -s #{count} -P #{shared_path}/pids/thin.pid'"
    invoke_command cmd, :via => via, :as => as
  end
  
  desc 'Restarts the thin server(s).'
  task :restart, :roles => :app, :except => { :no_release => true } do
    stop
    start
  end
  
  namespace :web do
    desc <<-DESC
      Present a maintenance page to visitors. Disables your application's web \
      interface by writing a "maintenance.html" file to each web server. The \
      servers must be configured to detect the presence of this file, and if \
      it is present, always display it instead of performing the request.
    
      By default, the maintenance page will just say the site is down for \
      "maintenance", and will be back "shortly", but you can customize the \
      page by specifying the REASON and UNTIL environment variables:
    
        $ cap deploy:web:disable \\
              REASON="hardware upgrade" \\
              UNTIL="12pm Central Time"
    
      Further customization will require that you write your own task.
    DESC
    task :disable, :roles => :web, :except => { :no_release => true } do
      require 'erb'
      
      path = fetch(:maintenance_file_path, "#{shared_path}/system/maintenance.html")
      on_rollback { run "rm #{path}" }

      reason = ENV['REASON']
      deadline = ENV['UNTIL']

      template = File.read(File.join(File.dirname(__FILE__), "templates", "maintenance.rhtml"))
      result = ERB.new(template).result(binding)

      put result, path, :mode => 0644
    end

    desc <<-DESC
      Makes the application web-accessible again. Removes the \
      "maintenance.html" page generated by deploy:web:disable, which (if your \
      web servers are configured correctly) will make your application \
      web-accessible again.
    DESC
    task :enable, :roles => :web, :except => { :no_release => true } do
      path = fetch(:maintenance_file_path, "#{shared_path}/system/maintenance.html")
      run "rm #{path}"
    end
  
  end

end

namespace :onebody do
  
  namespace :setup do
    desc 'Starts a thin server in setup mode on port 7999 (by default).'
    task :start, :roles => :app do
      as = fetch(:runner, 'app')
      via = fetch(:run_method, :sudo)
      port = fetch(:setup_port, 7999)
      env = 'setup'
      cmd = "sh -c 'cd #{current_path} && thin start -d -e #{env} -p #{port} -P #{shared_path}/pids/thin-setup.pid -l #{shared_path}/log/thin-setup.log'"
      invoke_command cmd, :via => via, :as => as
    end
    
    desc 'Stops the thin server in setup mode.'
    task :stop, :roles => :app do
      as = fetch(:runner, 'app')
      via = fetch(:run_method, :sudo)
      port = fetch(:setup_port, 7999)
      cmd = "sh -c 'cd #{current_path} && thin stop -p #{port} -P #{shared_path}/pids/thin-setup.pid'"
      invoke_command cmd, :via => via, :as => as
    end
    
    desc 'Retrieves the setup authorization secret.'
    task :secret, :roles => :app do
      secret = run_and_return("cat #{current_path}/setup-secret")
      puts
      puts 'The setup secret is:'
      puts secret
    end
  end
  
  namespace :scheduler do
    
    desc 'Starts the Scheduler daemon.'
    task :start, :roles => :app do
      as = fetch(:runner, 'app')
      via = fetch(:run_method, :sudo)
      env = fetch(:rails_env, 'production')
      cmd = "sh -c 'cd #{current_path} && script/scheduler start #{env}'"
      invoke_command cmd, :via => via, :as => as
    end   
     
    desc 'Stops the Scheduler daemon.'
    task :stop, :roles => :app do
      as = fetch(:runner, 'app')
      via = fetch(:run_method, :sudo)
      cmd = "sh -c 'cd #{current_path} && script/scheduler stop'"
      invoke_command cmd, :via => via, :as => as
    end
    
    desc 'Restarts the Scheduler daemon.'
    task :restart, :roles => :app do
      stop
      start
    end
    
  end

  namespace :shared do
    task :setup do
      run "mkdir -p #{shared_path}/db/photos/families"
      run "mkdir -p #{shared_path}/db/photos/groups"
      run "mkdir -p #{shared_path}/db/photos/people"
      run "mkdir -p #{shared_path}/db/photos/pictures"
      run "mkdir -p #{shared_path}/db/photos/recipes"
      run "mkdir -p #{shared_path}/db/publications"
      run "mkdir -p #{shared_path}/db/attachments"
      run "mkdir -p #{shared_path}/db/tasks"
      run "mkdir -p #{shared_path}/config"
      run "mkdir -p #{shared_path}/public"
      run "mkdir -p #{shared_path}/themes"
      unless run_and_return("ls #{shared_path}/config").match(/database\.yml/)
        yml = File.read(File.dirname(__FILE__) + '/templates/database.yml')
        put yml, "#{shared_path}/config/database.yml"
      end
    end
    after 'deploy:setup', 'onebody:shared:setup'
    
    task :point_db_dirs do
      rb = render_erb_template(File.dirname(__FILE__) + '/templates/links.rb')
      put rb, "#{release_path}/config/initializers/links.rb"
    end
    after 'deploy:update_code', 'onebody:shared:point_db_dirs'
    
    task :update_public_files do
      run "cp -r #{release_path}/public/* #{shared_path}/public/"
    end
    after 'deploy:update_code', 'onebody:shared:update_public_files'

    task :update_tasks do
      run "cp -r #{current_path}/db/tasks/* #{shared_path}/db/tasks/"
    end
    after 'onebody:shared:update_public_files', 'onebody:shared:update_tasks'
    
    task :create_symlinks do
      %w(config/database.yml public).each do |file|
        run "rm -rf #{release_path}/#{file}"
        run "ln -s #{shared_path}/#{file} #{release_path}/#{file}"
      end
    end
    after 'onebody:shared:update_tasks', 'onebody:shared:create_symlinks'

  end
  
end

class Capistrano::Configuration
  def render_erb_template(filename)
    template = File.read(filename)
    result   = ERB.new(template).result(binding)
  end
  
  def run_and_return(cmd)
    output = []
    run cmd do |ch, st, data|
      output << data
    end
    return output.to_s
  end
end